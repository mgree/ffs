.\" Automatically generated by Pandoc 2.9.1.1
.\"
.TH "FFS" "1" "" "Version 0.1.0" "File Filesystem Documentation"
.hy
.SH NAME
.PP
ffs - the file filesystem
.SH SYNOPSIS
.PP
ffs [\f[I]FLAGS\f[R]] [\f[I]OPTIONS\f[R]] [\f[I]INPUT\f[R]]
.PD 0
.P
.PD
ffs [\f[I]FLAGS\f[R]] [\f[I]OPTIONS\f[R]] --new [\f[I]OUTPUT\f[R]]
.PD 0
.P
.PD
ffs \f[I]--completions\f[R] \f[I]SHELL\f[R]
.PD 0
.P
.PD
ffs [\f[I]-h\f[R]|\f[I]--help\f[R]]
.PD 0
.P
.PD
ffs [\f[I]-V\f[R]|\f[I]--version\f[R]]
.SH DESCRIPTION
.PP
\f[I]ffs\f[R]---the \f[I]f\f[R]ile \f[I]f\f[R]ile\f[I]s\f[R]ystem---lets
you mount semi-structured data as a filesystem, allowing you to work
with modern formats using familiar shell tools.
.PP
\f[I]ffs\f[R] uses filesystems in userspace (FUSE); you must have these
installed on your system to use \f[I]ffs\f[R].
.PP
\f[I]ffs\f[R] expects its input to be encoded in UTF-8.
.SS Flags
.TP
-d, --debug
Give debug output on stderr
.TP
--exact
Don\[aq]t add newlines to the end of values that don\[aq]t already have
them (or strip them when loading)
.TP
-i, --in-place
Writes the output back over the input file
.TP
--no-output
Disables output of filesystem (normally on stdout)
.TP
--pretty
Pretty-print output (may increase size)
.TP
-q, --quiet
Quiet mode (turns off all errors and warnings, enables
\f[I]--no-output\f[R])
.TP
--readonly
Mounted filesystem will be readonly
.TP
--unpadded
Don\[aq]t pad the numeric names of list elements with zeroes; will not
sort properly
.TP
--no-xattr
Don\[aq]t use extended attributes to track metadata (see \f[I]man
xattr\f[R])
.TP
--keep-macos-xattr
Include ._* extended attribute/resource fork files on macOS.
.TP
-h, --help
Prints help information (and exits)
.TP
-V, --version
Prints version information (and exits)
.SS Options
.TP
--dirmode \f[I]DIRMODE\f[R]
Sets the default mode of directories (parsed as octal; if unspecified,
directories will have \f[I]FILEMODE\f[R], with execute bits set when
read bits are set) [default: 755]
.TP
--mode \f[I]FILEMODE\f[R]
Sets the default mode of files (parsed as octal) [default: 644]
.TP
-g, --gid \f[I]GID\f[R]
Sets the group id of the generated filesystem (defaults to current
effective group id)
.TP
-m, --mount \f[I]MOUNT\f[R]
Sets the mountpoint; will be inferred when using a file, but must be
specified when running on stdin
.TP
-o, --output \f[I]OUTPUT\f[R]
Sets the output file for saving changes (defaults to stdout)
.TP
--munge \f[I]MUNGE\f[R]
Set the name munging policy; applies to \[aq].\[aq], \[aq]..\[aq], and
files with NUL and \[aq]/\[aq] in them [default: rename] [possible
values: filter, rename]
.RS
.IP \[bu] 2
Under \f[I]--munge rename\f[R] (the default), fields named \[aq].\[aq]
and \[aq]..\[aq] will be renamed to \[aq]_.\[aq] and \[aq]_..\[aq],
respectively.
Every NUL byte will be replaced with the text \[aq]_NUL_\[aq] and every
forward slash will be replaced with the text \[aq]_SLASH_\[aq].
Unless you manually change the name of these renamed files, they will be
saved back with their original names, i.e., \[aq]_..\[aq] will turn back
into a field called \[aq]..\[aq], and \[aq]and_SLASH_or\[aq] will be
turned back into \[aq]and/or\[aq].
New files created with such names will not be converted back.
.IP \[bu] 2
Under \f[I]--munge filter\f[R], fields named \[aq].\[aq], \[aq]..\[aq],
or with NUL or \[aq]/\[aq] in them will simply be dropped (with a
warning).
.RE
.TP
--new \f[I]NEW\f[R]
Mounts an empty filesystem, inferring a mountpoint and output format.
Running \f[I]--new\f[R] \f[I]FILE\f[R].\f[I]EXT\f[R] is morally
equivalent to running:
.RS
.IP
.nf
\f[C]
echo \[aq]{}\[aq] | ffs --source json -o *FILE*.*EXT* --target *EXT* -m *FILE*
\f[R]
.fi
.PP
where the mountpoint \f[I]FILE\f[R] will be created (and removed) by
ffs.
.RE
.TP
--completions \f[I]SHELL\f[R]
Generate shell completions (and exits) [possible values: bash, fish,
zsh]
.TP
-s, --source \f[I]SOURCE_FORMAT\f[R]
Specify the source format explicitly (by default, automatically inferred
from filename extension) [possible values: json, toml, yaml]
.TP
-t, --target \f[I]TARGET_FORMAT\f[R]
Specify the target format explicitly (by default, automatically inferred
from filename extension) [possible values: json, toml, yaml]
.TP
-u, --uid \f[I]UID\f[R]
Sets the user id of the generated filesystem (defaults to current
effective user id)
.SS Arguments
.TP
\f[I]INPUT\f[R]
Sets the input file (use \[aq]-\[aq] for stdin) [default: -]
.SS Data model
.PP
The data model for \f[I]ffs\f[R] is a superset of that of its supported
formats (currently, JSON, TOML, and YAML); \f[I]ffs\f[R] maps values in
these formats to filesystems.
Here are the different types and how they\[aq]re mapped to a filesystem:
.TP
auto
Automatically detected.
The following order is used for UTF-8 encodable data: null, boolean,
integer, float, datetime, string.
If data can\[aq]t be encoded in UTF-8, it will always be bytes.
.TP
boolean
Mapped to a \f[B]file\f[R].
Either \f[I]true\f[R] or \f[I]false\f[R].
.TP
bytes
Mapped to a \f[B]file\f[R].
When saving, bytes are typically encoded in base64.
.TP
datetime
Mapped to a \f[B]file\f[R].
Some portion of an RFC
3339 (https://datatracker.ietf.org/doc/html/rfc3339) date/time.
.TP
integer
Mapped to a \f[B]file\f[R].
No larger than 64 bits.
.TP
float
Mapped to a \f[B]file\f[R].
No larger than 64 bits.
.TP
list
Mapped to a \f[B]directory\f[R].
List directories will have numerically named elements, starting from 0.
Filenames will be padded with zeros to ensure proper sorting; use
\f[I]--unpadded\f[R] to disable padding.
While mounted, you are free to use whatever filenames you like in a list
directory.
When list directories are saved, filenames are ignored and the sorted
order of the files (in the current locale) will be used to determine the
list order.
.TP
named
Mapped to a \f[B]directory\f[R].
Named directories (also known as maps, objects, hashes, or dictionaries)
will use field names as the file/directory names for their contents.
Some renaming may occur if fields have special characters in them; see
\f[I]--munge\f[R] above.
.TP
null
Mapped to a \f[B]file\f[R].
The file will be empty.
.TP
string
Mapped to a \f[B]file\f[R].
The file will be encoded in UTF-8 holding the string.
.PP
By default every file will have a newline appended to its contents; this
newline will be removed when the filesystem is dumped back to a file.
To disable these newlines, use \f[I]--exact\f[R].
.PP
You can inspect and alter the types of files and directories using the
extended attribute \f[I]user.type\f[R] (use \f[I]xattr\f[R] on macOS and
\f[I]attr\f[R]/\f[I]getfattr\f[R]/\f[I]setfattr\f[R] on Linux).
The names given here are the valid values for the \f[I]user.type\f[R]
attribute.
.SH ENVIRONMENT
.TP
RUST_LOG
Configures tracing output.
Use the format \f[I]key\f[R]=\f[I]level\f[R], where \f[I]key\f[R] should
probably be \f[I]ffs\f[R] and \f[I]level\f[R] should be one of
\f[I]error\f[R], \f[I]warn\f[R], \f[I]info\f[R], \f[I]debug\f[R], or
\f[I]trace\f[R].
The default is \f[I]ffs=warn\f[R].
Setting \f[I]-q\f[R] turns off all output; setting \f[I]-d\f[R] sets
\f[I]ffs=debug\f[R].
.SH EXAMPLES
.PP
The general workflow is to run \f[I]ffs\f[R], do some work, and then
unmount the mountpoint using \f[I]umount\f[R].
It\[aq]s typical to run \f[I]ffs\f[R] in the background, since the
program will not terminate until the userspace filesystem is unmounted.
.PP
By default, \f[I]ffs\f[R] will work off of stdin, in which case you must
specify a mountpoint with \f[I]-m\f[R].
If you have a mountpoint/directory \f[I]mnt\f[R], you can download
information on GitHub commits, work with them, and save the modified
output to \f[I]commits.json\f[R] by running:
.IP
.nf
\f[C]
curl https://api.github.com/repos/mgree/ffs/commits | ffs -m mnt -o commits.json 
\f[R]
.fi
.PP
If you had already downloaded the file to \f[I]commits.json\f[R], you
could simply run:
.IP
.nf
\f[C]
ffs -i commits.json
# do edits in commits directory
umount commits
# changes are written back to commits.json (-i is in-place mode)
\f[R]
.fi
.PP
If you want to create a new file wholesale, the \f[I]--new\f[R] flag is
helpful.
.IP
.nf
\f[C]
ffs --new file.json
# do edits in file directory
umount file
# corresponding json is in file.json
\f[R]
.fi
.PP
To mount a JSON file and write back out a YAML file, you could run:
.IP
.nf
\f[C]
ffs -o output_data.yaml input_data.json
# do edits in the input_data directory ffs created
umount input_data
\f[R]
.fi
.PP
When filenames are present, extensions will be used to infer the format
being used.
You can specify the source and target formats explicitly with
\f[I]--source\f[R] and \f[I]--target\f[R], respectively.
.PP
You can use extended attributes to change a list directory to a named
one (or vice versa); this example uses macOS, with Linux alternatives in
comments.
.IP
.nf
\f[C]
$ ffs -i list.json &
[1] 41361
$ cat list.json
[1,2,\[dq]3\[dq],false]
$ cd list
$ mv 0 loneliest_number
$ mv 1 to_tango
$ mv 2 three
$ mv 3 not_true
$ xattr -l .                    # Linux: getattr --match=- .
user.type: list
$ xattr -w user.type named .    # Linux: setattr -n user.type -v named .
$ ls
loneliest_number not_true         three            to_tango
$ cd ..
$ umount list
$
[1]+  Done                    target/debug/ffs -i list.json
$ cat list.json
{\[dq]loneliest_number\[dq]:1,\[dq]not_true\[dq]:false,\[dq]three\[dq]:\[dq]3\[dq],\[dq]to_tango\[dq]:2}
\f[R]
.fi
.SH SEE ALSO
.PP
attr(1), fuse(4), fusermount(3), getfattr(1), mount(8), setfattr(1),
umount(8), xattr(1)
.PP
To learn more about FUSE (Filesystem in Userspace), check out libfuse
(Linux) <https://github.com/libfuse/libfuse> and macFUSE (macOS)
<https://osxfuse.github.io/>.
.SH BUGS
.PP
See <https://github.com/mgree/ffs/issues>.
.SH LICENSE
.PP
Copyright 2021 (c) Michael Greenberg.
GPL-3.0 licensed.
.SH AUTHORS
Michael Greenberg.
